import { AllDataDD, CompDataD, isDataDd, isPrimDd, isRepeatingDd, OneDataDD } from "../common/dataD";
import { unique } from "../common/restD";
import { indentList } from "./codegen";
import { dbMapname } from "./names";

export interface FindParentChildControls {
  stopAtResolvers?: boolean;
  includePrimitives?: boolean
}
export function findParentChildCompDataLinks<G> ( d: CompDataD<G>, { stopAtResolvers, includePrimitives }: FindParentChildControls ): [ CompDataD<G>, OneDataDD<G> ][] {
  function makeLinksForChild ( d: CompDataD<G> ): [ CompDataD<G>, OneDataDD<G> ][] {
    if ( isRepeatingDd ( d ) ) return makeParentChildrenStoppingAtResolvers ( d, d.dataDD )
    if ( isDataDd ( d ) ) return Object.entries ( d.structure ).flatMap ( ( [ name, data ] ) => makeParentChildrenStoppingAtResolvers ( d, data ) )
    throw Error ( `Cannot process dataD ${d}` )
  }
  function makeParentChildrenStoppingAtResolvers ( parent: CompDataD<G>, oneDataD: OneDataDD<G> ): [ CompDataD<G>, OneDataDD<G> ][] {
    const d = oneDataD.dataDD
    if ( isPrimDd ( d ) ) return includePrimitives ? [ [ parent, oneDataD ] ] : []
    if ( stopAtResolvers && d.resolver ) return [ [ parent, oneDataD ] ]
    return [ [ parent, d ], ...makeLinksForChild ( d ) ]
  }
  return makeLinksForChild ( d )
}

export function makeGraphQlResultMaps<G> ( name: string, parentChild: [ CompDataD<G>, AllDataDD<G> ][] ) {
  const dataDs = unique ( parentChild.flat (), d => d.name )
  return [ `public static class ${name} {`,
    ...indentList ( dataDs.map ( d => `public final Map ${dbMapname ( d )} = new HashMap();` ) ),
    ...indentList ( parentChild.map ( ( [ p, c ] ) => `${dbMapname ( p )}.put("${dbMapname ( c )}", ${dbMapname ( c )});` ) ),
    '}' ]
}
